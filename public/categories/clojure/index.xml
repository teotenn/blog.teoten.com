<?xml version="1.0" encoding="UTF-8"?><rss><channel><title>Teoten's blog</title><link rel="self" href="https://blog.teoten.com/index.xml/" type="application/rss+xml">https://blog.teoten.com</link><description>Recent content on Teoten's blog</description><language>en</language><updated>Tue Oct 08 02:00:00 CEST 2024</updated><lastBuildDate>Thu Jan 23 13:55:38 CET 2025</lastBuildDate><item><title>Leveraging AI to Enhance Functional Programming in 2025</title><link href="https://blog.teoten.com/posts/2024/ai_to_enhance_functional_programming/">https://blog.teoten.com/posts/2024/ai_to_enhance_functional_programming/</link><pubDate>Tue Dec 31 01:00:00 CET 2024</pubDate><author>Teoten</author><guid></guid><categories>R, clojure, </categories><description type="html">&lt;article id="post-/posts/2024/ai_to_enhance_functional_programming/" data-post-id="/posts/2024/ai_to_enhance_functional_programming/"&gt;&lt;div&gt;
 &lt;h1 class="article-header"&gt;Leveraging AI to Enhance Functional Programming in 2025&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Functional programming has always stood out as an elegant approach to software development. Its focus on pure functions, immutability, and composability ensures clarity, predictability, and easier debugging. Languages like R, Python, and Clojure, each with their unique strengths, are particularly well-suited for functional programming paradigms. But what happens when we combine this structured approach with the power of modern AI tools? A world of efficiency and creativity opens up.&lt;/p&gt;
  &lt;p&gt;In this post, we’ll explore how to use AI to create individual functions that can later be composed into a complete program using functional programming principles. Let’s start by revisiting the core advantages of functional programming and then delve into how AI can enhance this workflow.&lt;/p&gt;
  &lt;p&gt;&lt;/p&gt;
 &lt;h2 class="article-header"&gt;Advantages of Functional Programming&lt;/h2&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;&lt;span&gt;1. &lt;strong&gt;Modularity:&lt;/strong&gt; Functions are independent and self-contained, making them easy to compose and reuse. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;2. &lt;strong&gt;Testability:&lt;/strong&gt; Pure functions depend solely on their inputs and produce consistent outputs, simplifying debugging and testing. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;3. &lt;strong&gt;Concurrency:&lt;/strong&gt; Immutability and statelessness reduce race conditions, making functional programs naturally suited for parallelism. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;4. &lt;strong&gt;Readability and Maintainability:&lt;/strong&gt; Code is more predictable and easier to understand when side effects are minimized. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;With these principles in mind, functional programming thrives on creating reliable, isolated functions. This makes it a natural match for AI tools, which excel at generating discrete, task-specific code snippets.&lt;/p&gt;
  &lt;p&gt;&lt;/p&gt;
 &lt;h2 class="article-header"&gt;Using AI to Generate Functions&lt;/h2&gt;
 &lt;p&gt;AI engines can help you efficiently generate functions tailored to specific tasks. Here’s how you can incorporate AI into your functional programming workflow:&lt;/p&gt;
 &lt;h3 class="article-header"&gt;1. Defining the Task&lt;/h3&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Clearly articulate the task you want the function to perform. You can be as specific as you want. I have noticed that, the more specific you are in one single prompt, the better. On the contrary, I have noticed that when you allow the engine to get context through a long conversation it usually does more mistakes. Here are some hints:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Start by telling which programming language it should use, and if you have some preferences in libraries include it here. Example: "Create a function in R using the purrr library that does...".&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Continue by telling what exactly the function should do. Example: "... a function that filters even numbers from a list".&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;At this step it can help by telling the engine what to expect as an input and what to give as an output. From the previous example: "... a function that, given a list of numbers as a single string, filters even numbers and returns them as a vector".&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;It is also helpful to provide examples and give some data. Example: "for example, from the string '1, 2, 3, 4, 5, 6, 7' it should return the vector with the values 2, 4 and 6 only".&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;You can also request additional parameters to take, and specify what should they do. For example: "add a parameter 'length' to specify the maximum length of the vector to be returned".&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;span&gt;
   &lt;/span&gt;&lt;p&gt;The key is to be specific about inputs, outputs, and any constraints or edge cases. The example above can end up in something like this:&lt;/p&gt;
   &lt;p&gt;&lt;span&gt;&lt;em&gt;Using R and the library purrr, create a function that, given a string of numbers, returns a vector with only the even numbers in it. In the string, the numbers are separated by comma. For example, from the string "1, 2, 3, 4, 5, 6, 7" it should return c(2, 4, 6). Additionally, add a parameter called "length" to specify the maximum size of the final vector.&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
 &lt;h3 class="article-header"&gt;2. Testing in the REPL&lt;/h3&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Once the AI generates the function, the REPL (Read-Eval-Print Loop) environments, also known simply as consoles, allow you to test and refine it in isolation. Here’s an example workflow:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Paste the generated function into your script with a commented note that it is a work in progress.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Evaluate the function into the REPL. You could as well paste it directly into the REPL but it gives you less space for tuning it.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Test it with various inputs to verify correctness.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Debug or tune the function as necessary.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;span&gt;
   &lt;/span&gt;&lt;p&gt;If issues arise, you can return to the AI with detailed feedback, asking it to refine or enhance the function. For example, you might request better error handling, additional parameters, optimizations for edge cases or a particular library/function to be used within it.&lt;/p&gt;
   &lt;p&gt;&lt;/p&gt;
 &lt;h2 class="article-header"&gt;Building a Complete Program&lt;/h2&gt;&lt;span&gt;&lt;span&gt;
   &lt;/span&gt;&lt;/span&gt;&lt;p&gt;Once you have a collection of tested functions, the next step is composition. Functional programming encourages composing small, tested functions into larger workflows. This step is typically less dependent on AI since you're now applying domain-specific business logic. Here it is more of a personal choice how to place the functions together, how they call each other, and what is your final main function(s). At this engineering stage we can also tune the details of the business logic, in case that particular details are needed.&lt;/p&gt;
   &lt;p&gt;However, you can still consult the AI for advice, such as:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Strategies for composing functions.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Suggestions for structuring the program to maintain functional purity.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Recommendations for efficient data flow between functions.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Recommendations for optimization.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Advice on how to handle sensitive information, such as login credentials.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;&lt;/p&gt;
 &lt;h2 class="article-header"&gt;Documentation and Unit Testing with AI&lt;/h2&gt;
 &lt;p&gt;AI tools are not only great at generating code but can also help you finalize your project by:&lt;/p&gt;
 &lt;h3 class="article-header"&gt;Generating Documentation&lt;/h3&gt;&lt;span&gt;
  &lt;/span&gt;&lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Ask the AI to create comprehensive docstrings or external documentation based on your code.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Ensure the documentation highlights inputs, outputs, and edge cases, maintaining clarity and professionalism.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;You can also ask the AI engine to create simple reproducible examples for it.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
 &lt;h3 class="article-header"&gt;Creating Unit Tests&lt;/h3&gt;&lt;span&gt;
  &lt;/span&gt;&lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Request the AI to generate unit tests for each function. For example:&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;&lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;In Python, ask for &lt;code&gt;unittest&lt;/code&gt; or &lt;code&gt;pytest&lt;/code&gt; test cases. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;In R, request &lt;code&gt;testthat&lt;/code&gt; test scripts. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
    &lt;li&gt;
     &lt;p&gt;In Clojure, ask for test functions using its native testing tools.&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;/div&gt;&lt;li&gt;
    &lt;p&gt;AI can provide thorough coverage by suggesting test cases you might not have considered.&lt;/p&gt;&lt;/li&gt;
  &lt;span&gt;
   &lt;/span&gt;&lt;p&gt;With documentation and tests generated, you have a robust, production-ready program created efficiently and collaboratively with AI.&lt;/p&gt;
   &lt;p&gt;&lt;/p&gt;
 &lt;h2 class="article-header"&gt;The AI-Functional Programming Symbiosis&lt;/h2&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Combining functional programming with AI tools offers several benefits:&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;1. &lt;strong&gt;Efficiency:&lt;/strong&gt; AI accelerates the creation of task-specific functions and peripheral code like tests and documentation. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;2. &lt;strong&gt;Focus:&lt;/strong&gt; Developers can concentrate on high-level design and logic while offloading repetitive or boilerplate tasks to the AI. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;3. &lt;strong&gt;Error Reduction:&lt;/strong&gt; By iterating with AI, you can quickly address edge cases, improve error handling, and refine implementations. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;4. &lt;strong&gt;Accessibility:&lt;/strong&gt; Functional programming’s modular nature aligns well with AI’s ability to handle isolated problems, making the entire workflow approachable and scalable. &lt;/span&gt;&lt;/p&gt;
 &lt;h1 class="article-header"&gt;The options&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;By the end of 2024 many options have appeared and made available publicly. Here are some that I have tried:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;a href="https://chatgpt.com/"&gt;Chat GPT&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;a href="https://claude.ai"&gt;claude&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;a href="https://codeium.com"&gt;codeium&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;a href="https://copilot.microsoft.com"&gt;copilot&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;a href="https://gemini.google.com/"&gt;gemini&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;&lt;/p&gt;
 &lt;h1 class="article-header"&gt;Dealing with bugs&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;As we enter into 2025, most of the models have been refined and the resulting code is performing better. Nevertheless, there are still a lot of details that are unknown by the engine that can cause trouble to your code. Here are some that I have faced myself:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;The function does not actually do what you expect: Here it helps to be more specific and provide examples. You can develop this along the chat, but in my experience, the longer the chat gets, the more confused the engine becomes. When this happens, it is useful to start from scratch again with a new prompt that is more specific and learned from the previous mistakes.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Simple bugs: Sometimes the function is simply bugged. Here you can simply copy and paste the error message and the AI will help you to troubleshoot. However, there are cases that are not so easily identifiable by the engine. Such as the ones below:&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Recommending outdated libraries: I have been suggested to use libraries that haven't been maintained for over 5 years and thus, some functions are buggy. However, the AI engines knew nothing about it and were suggesting solutions that did not work. I solved it by asking it to use a different library.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Using non-existent parameters: Very rarely, the AI model would recommend to use a function in a certain way, by passing specific parameters that are actually not used by the function. This usually happens in less popular libraries or languages (such as emacs lisp) and my guess is that the engine is not well trained because the info about it is scarce. It is usually solved by telling it that it does not take such parameter, adding the documentation, or simply suggesting to use a different function or library.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
 &lt;h1 class="article-header"&gt;Conclusion&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;The combination of AI tools and functional programming paradigms unlocks new levels of productivity and creativity in software development. By leveraging AI to generate, test, document, and enhance individual functions, you can efficiently build robust and maintainable programs, deal more efficiently with potential bugs and learn along the way about new functions or different implementations of the same old ones. The iterative nature of this workflow - moving between the AI and your REPL - ensures that each piece of the puzzle fits perfectly before assembling the whole.&lt;/p&gt;
  &lt;p&gt;As AI continues to evolve, its role in programming will only grow, complementing the structured, thoughtful approach that functional programming embodies. So, whether you're working in R, Python, Clojure or something else, embrace this synergy and see how it transforms your coding experience.&lt;/p&gt;
&lt;/article&gt;</description></item><item><title>Building my blog from scratch</title><link href="https://blog.teoten.com/posts/2024/building_my_blog_from_scratch/">https://blog.teoten.com/posts/2024/building_my_blog_from_scratch/</link><pubDate>Tue Oct 08 02:00:00 CEST 2024</pubDate><author>Teoten</author><guid></guid><categories>clojure, web-dev, </categories><description type="html">&lt;article id="post-/posts/2024/building_my_blog_from_scratch/" data-post-id="/posts/2024/building_my_blog_from_scratch/"&gt;&lt;div&gt;
 &lt;span&gt;
  &lt;/span&gt;&lt;p&gt;&lt;span&gt;For the last 4 years, my personal blog was built using &lt;a href="https://gohugo.io/"&gt;Hugo&lt;/a&gt;, one of the most popular static site generators. Back then I wanted to just start writing content about R and publish it quickly and easily into my own blog. It worked out well, since Hugo is an excellent tool for quickly spinning up a static site. However, over time, I began to feel restricted by its framework and frustrated by the bugs, and decided to take on the challenge of building my blog from scratch. The journey has not only given me more control but has also helped me sharpen my skills in web development, specifically in Clojure. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;Here I want to share and register part of the experience to look back in a few years time and to inspire others to take the same challenge. I really get a gratifying feeling each time I build some service on my own.&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;You can have a look at the source code on &lt;a href="https://github.com/teotenn"&gt;my github&lt;/a&gt; under the repo &lt;a href="https://github.com/teotenn/blog.teoten.com"&gt;blog.teoten.com&lt;/a&gt;. &lt;/span&gt;&lt;/p&gt;
 &lt;h1 class="article-header"&gt;Why Move Away from Hugo?&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Hugo offers a fantastic set of features out of the box: it's fast, flexible, and supports a variety of formats like Markdown and Org-mode, making it an ideal tool for many developers. However, as my blog evolved, I started to encounter some limitations that motivated me to look for a more personalized solution.&lt;/p&gt;
  &lt;p&gt;It happened a few times that, without updating anything in particular, I was getting bugs about some specific line of code in a template, or even weirder bugs that I did not understand. I managed to solved them by rolling back or opening issues in the GitHub repositories and receiving support.&lt;/p&gt;
  &lt;p&gt;Nevertheless, a couple of weeks ago, after a long break from publishing due to family duties, I came back full of inspiration, wishing to share my new learned skills in Clojure, just to encounter one more bug related to the templates. Only that this time I told myself that it was enough, and that it shouldn't be so difficult to build my own site with such a great tool as Clojure. So, I decided to say goodbye to Hugo for good.&lt;/p&gt;
 &lt;h2 class="article-header"&gt;Disadvantages of Using a Framework Like Hugo&lt;/h2&gt;&lt;span&gt;&lt;span&gt;
   &lt;/span&gt;&lt;/span&gt;&lt;p&gt;I am left very thankful to Hugo and all the team behind it, as well as the big bunch of people creating themes and sharing them for free. It is a very nice community that hold my project for 4 full years with minimal frustrations. I would totally recommend Hugo to any person wishing to start a blog quickly and easily without knowledge of the stack, or even with very little knowledge of programming in general.&lt;/p&gt;
   &lt;p&gt;However, as any framework, it also has its own disadvantages. In my experience, these were some of them:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Lack of Control: Hugo abstracts away a lot of complexity, which is great when you're just starting out. But this abstraction comes at a cost. When things break, whether it's related to a theme, the build process, or some obscure plugin, you're often left in the dark. Debugging can become frustrating without full knowledge of what's happening under the hood.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Theme Dependency: The reliance on external themes was another drawback. While themes provide flexibility, they often contain extra features that I didn't need, and customizing them wasn't always straightforward. I found myself constantly searching for fixes to theme-related issues, which added unnecessary complexity.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Stack Ignorance: Hugo is written in Go, a language I am not familiar with. While I could use it without knowing the language, I felt disconnected from my own website's build process. This lack of deeper understanding led me to feel like I didn't truly own my site's stack.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;Feature Overload: Hugo provides an overwhelming number of features, many of which I never used. I began to crave a more lightweight, minimalist solution where I had full control over every aspect of the site.&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
 &lt;h2 class="article-header"&gt;What I Wanted Instead:&lt;/h2&gt;&lt;span&gt;
  &lt;/span&gt;&lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;strong&gt;More Control&lt;/strong&gt;: By building my own static site generator, I could understand every line of code, making it easier to troubleshoot and customize exactly the way I wanted. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;strong&gt;Improved Skills&lt;/strong&gt;: I wanted to challenge myself and improve my coding skills, particularly with clojure, frontend development, as well as learn more about search engine optimization (SEO). &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;span&gt;&lt;strong&gt;Ownership of the Stack&lt;/strong&gt;: Rather than relying on a pre-built framework, I wanted to fully understand and control the process of converting content into a static website. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;Therefore, I embarked myself in a pretty fun journey of building my own site.&lt;/p&gt;
 &lt;h1 class="article-header"&gt;Using clojure to build a static site&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;I started learning Clojure at the beginning of 2024, and it's been fascinating. It has many of the qualities of the Lisp languages, which taught me functional programming and give me my everyday coding tools (Emacs), but it comes with some advantages by being host in the JVM and thanks to its native design to overcome some of the downsides of Common Lisp. Therefore, it was a natural choice for building my blog.&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;My first search for resources to get started showed me that there are a few good frameworks to build static websites and blogs with Clojure as well. But since frameworks was one of the things I wanted to avoid, I went on looking. I found this &lt;a href="https://cjohansen.no/building-static-sites-in-clojure-with-stasis/"&gt;excellent tutorial&lt;/a&gt; by &lt;a href="https://cjohansen.no/"&gt;Christian Johansen&lt;/a&gt; about building with &lt;a href="https://github.com/magnars/stasis"&gt;stasis&lt;/a&gt; and followed it to have my first site generator up and running after one evening of coding. However, his tutorial does not give me half of the tools I needed and wanted to use. It is based on markdown files, which I use, but I use org too. It is built using &lt;a href="https://leiningen.org/"&gt;leiningen&lt;/a&gt; and I wanted to use the built in &lt;a href="https://clojure.org/guides/deps_and_cli"&gt;CLI and deps.edn&lt;/a&gt;&lt;span&gt;. I was also wishing to generate an RSS feed in xml, to have a &lt;code&gt;config.edn&lt;/code&gt; file and set up environments, among others. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;After initializing a git repo with the guide, I moved forward on my own and started crafting pieces here and there. This approach gave me the flexibility I was craving and the chance to dive deeper into programming concepts I hadn't previously explored.&lt;/p&gt;
 &lt;h2 class="article-header"&gt;My personal Stack&lt;/h2&gt;&lt;span&gt;
  &lt;/span&gt;&lt;pre&gt;&lt;code class="highlight"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"src"&lt;/span&gt; &lt;span class="s"&gt;"resources"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

 &lt;span class="ss"&gt;:deps&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojure&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.11.1"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;stasis/stasis&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"2023.11.21"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;hiccup/hiccup&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"2.0.0-RC3"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;ring/ring-core&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.12.2"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;ring/ring-jetty-adapter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.12.2"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;markdown-clj/markdown-clj&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.12.1"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;optimus/optimus&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"2023.11.21"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;enlive/enlive&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.1.6"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;clygments/clygments&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt;  &lt;span class="s"&gt;"2.0.2"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;org.jsoup/jsoup&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.18.1"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;cprop/cprop&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"0.1.20"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;selmer/selmer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.12.61"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;clj-time/clj-time&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt;  &lt;span class="s"&gt;"0.15.2"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;org.clojure/data.xml&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"0.0.8"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;hickory/hickory&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"0.7.1"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="nv"&gt;clj-org/clj-org&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"0.0.3"&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;

 &lt;span class="ss"&gt;:aliases&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:dev&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:extra-paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"dev"&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
  &lt;span class="c1"&gt;;; Call with `clj -X:build-site`&lt;/span&gt;
  &lt;span class="ss"&gt;:build-site&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:exec-fn&lt;/span&gt; &lt;span class="nv"&gt;teoten.ttblog.core/-main&lt;/span&gt;
               &lt;span class="ss"&gt;:exec-args&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:env&lt;/span&gt; &lt;span class="ss"&gt;:builder&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
  &lt;span class="c1"&gt;;; clj -X:test&lt;/span&gt;
  &lt;span class="ss"&gt;:test&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:extra-paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
         &lt;span class="ss"&gt;:extra-deps&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;lambdaisland/kaocha&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:mvn/version&lt;/span&gt; &lt;span class="s"&gt;"1.91.1392"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                      &lt;span class="c1"&gt;;; midje/midje {:mvn/version "1.10.10"}&lt;/span&gt;
                      &lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="ss"&gt;:exec-fn&lt;/span&gt; &lt;span class="nv"&gt;kaocha.runner/exec-fn&lt;/span&gt;
         &lt;span class="ss"&gt;:exec-args&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:skip-meta&lt;/span&gt; &lt;span class="ss"&gt;:slow&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
  &lt;span class="p"&gt;}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;span&gt;
   &lt;/span&gt;&lt;p&gt;Here's a quick breakdown of my stack:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;Content Parsing: I'm using Markdown, &lt;a href="https://orgmode.org/"&gt;Org-mode&lt;/a&gt;, and raw HTML files generated by the native org-mode on Emacs. These three formats are then parsed into HTML using tools like &lt;a href="https://github.com/yogthos/markdown-clj"&gt;markdown-clj&lt;/a&gt; and &lt;a href="https://github.com/eigenhombre/clj-org"&gt;clj-org&lt;/a&gt;, which handle the different content types effortlessly. Furthermore, I can choose between using a plain org file, or its resulted parsed file in html format. This helps me to overcome some of the limitations of the clojure org parser (which are many) and allows me to use the power of Emacs and org-mode themselves. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;Static Site Generation: The core of my site generation relies on &lt;a href="https://github.com/magnars/stasis"&gt;stasis&lt;/a&gt;, a minimalistic Clojure library for creating static websites. It handles routing, file generation, and serves as the glue that ties the content to the final HTML pages. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;HTML Templating: I'm using &lt;a href="https://github.com/yogthos/Selmer"&gt;Selmer&lt;/a&gt; for HTML templating and &lt;a href="https://github.com/weavejester/hiccup"&gt;Hiccup&lt;/a&gt;/&lt;a href="https://github.com/clj-commons/hickory"&gt;Hickory&lt;/a&gt; for DOM manipulation. These tools give me fine-grained control over how my pages are structured and rendered. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;RSS Generation: I generate the blog's RSS feed with Clojure's &lt;a href="https://github.com/clojure/data.xml"&gt;data.xml&lt;/a&gt; library, ensuring that my content can be syndicated properly. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;Functional programming: My builder holds very little state (clojure's &lt;code&gt;atom&lt;/code&gt;) and relies on functions, which allows me to do error handling, unit testing and refactoring like a breeze. Additionally, I can use support of generative AI by simply asking for "a function that takes x arguments to achieve z results", which keeps my mind free of worries about side effects or inheritance, and instead can focus only on the potential bugs and error handling, easily managed by the unit test. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;&lt;span&gt;Server for development: I am using &lt;a href="https://ring-clojure.github.io/ring/ring.adapter.jetty.html"&gt;ring adapter jetty&lt;/a&gt; from the &lt;a href="https://github.com/ring-clojure/ring"&gt;ring&lt;/a&gt; library to have a live view of my blog during development and drafting. This means that I can be typing a new post and see my changes directly on the browser by just refreshing the page. Or refactoring some old functions and after evaluating them, refresh the browser and see the results. &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;p&gt;CSS Styling: One of the most satisfying parts has been designing the CSS for the site from scratch. I have used Bootstrap and Tailwind in the past, but again, frameworks. Using my own custom CSS not only makes the site unique but has also taught me a lot about styling and responsive design.&lt;/p&gt;&lt;/li&gt;
   &lt;/ul&gt;
 &lt;h2 class="article-header"&gt;Challenges&lt;/h2&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;&lt;span&gt;The first challenge I encountered was the use of &lt;a href="https://github.com/cgrand/enlive"&gt;Enlive&lt;/a&gt; by the tutorial. I followed along, and used some pieces of code from it, which just "worked", but I couldn't wrap my head around it. Since I wanted to have more control over my stack, I went ahead and try to learned it by creating a function to do something specific (at this point I have forgotten what exactly) but I couldn't. I looked into the repository and documentation just to find out that there was an open issue with a similar problem, and it was no solved. Then I realized that the last commit was 5 years ago, and there are 21 open issues at the moment of writing this. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;I kept the working code and moved away from Enlive for further DOM manipulation, and found some help for using &lt;a href="https://jsoup.org/"&gt;Jsoup&lt;/a&gt;, a Java library that I can call from Clojure (advantages of JVM hosted). It gave me the tools I needed but I didn't enjoy it as much as writing pure Clojure. Plus, I could barely have the work done, without fully understanding the code I was writing. Luckily, I came across &lt;a href="https://github.com/clj-commons/hickory"&gt;hickory&lt;/a&gt; when I needed to do more manipulation, and it is what I am using now together with &lt;a href="https://github.com/weavejester/hiccup"&gt;hiccup&lt;/a&gt;, which I'm more used to from working with &lt;a href="https://clojurescript.org/"&gt;Clojurescript&lt;/a&gt;. Hickory is more intuitive, documented and clojure-like, providing flexibility in the data structures to work with Hickory or Hiccup-style, both of which are very "clojurist" and are easy to use. &lt;/span&gt;&lt;/p&gt;
  &lt;p&gt;&lt;span&gt;Another big challenge for me was the creation of a custom CSS, which I really wanted to do to improve my skills. So far I had worked with CSS by copying snippets of code, or using Bootstrap or Tailwind and then having a minimal CSS file for granular details. But building the CSS from scratch has been quite a challenge, which I decided to face with the help of generative AI. I been using &lt;a href="https://openai.com/chatgpt/"&gt;ChatGPT&lt;/a&gt; and &lt;a href="https://codeium.com/"&gt;Codeium&lt;/a&gt;&lt;span&gt; to ask for advice, get code snippets and solve problems with my styles. Although challenging, I have learned a great deal about styling with CSS, using variables, responsive design and the importance of the &lt;code&gt;div&lt;/code&gt; tag. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;h1 class="article-header"&gt;The Satisfaction of Building from Scratch&lt;/h1&gt;&lt;span&gt;
  &lt;/span&gt;&lt;p&gt;Building my blog from the ground up has been both fun and educational. I've learned a ton about Clojure, from how to manipulate data structures to leveraging libraries that handle everything from routing to RSS generation. I now understand almost every step of my site generation process (I still need to change a few pieces of Enlive and Jsoup code) and can troubleshoot issues quickly without having to rely on external frameworks.&lt;/p&gt;
  &lt;p&gt;That said, there's still plenty of work ahead. My frontend design is far from polished, and my SEO is still a work in progress. I also need to implement sections for tags and categories to improve content navigation. And the generator itself needs more work in the unit test and error handling. However, despite these shortcomings, I feel incredibly satisfied and fulfilled knowing that I built this system by myself.&lt;/p&gt;
  &lt;p&gt;After following the tutorial from Johansen, I thought that I could have my blog up and running, with minimal functionality, in a week. It anyway took me 2 weeks to reach a version I was satisfied with, which is not long considering that I had my expectations as high as my demands.&lt;/p&gt;
  &lt;p&gt;For anyone considering a similar path, I highly recommend taking the plunge. It's an amazing opportunity to grow as a developer, and the control and customization options you gain are worth the effort. I will share some of my experiences with pieces of the builder as the time goes, but feel free to reach out and ask for directions, support or particular topics you could be interested in.&lt;/p&gt;
&lt;/div&gt;&lt;/article&gt;</description></item></channel></rss>