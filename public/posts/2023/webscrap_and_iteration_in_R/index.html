<html>
 <head>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
  <link href="/styles/ba8a5a958775/syntax_highlight.css" rel="stylesheet">
  <link href="/styles/4033ae4f54f9/styles.css" rel="stylesheet">
 </head>
 <body>
  <!-- Top nav bar -->
  <div>
   <!-- Toggle Button -->
   <button id="theme-toggle-btn" onclick="toggleTheme()">T</button>
   <div id="wrapper">
    <nav id="navbar">
     <ul>
      <li><a href="https://blog.teoten.com/">Home</a></li>
      <li><a href="https://blog.teoten.com/list/">Posts</a></li>
      <li><a href="https://blog.teoten.com/about/">About</a></li>
     </ul>
    </nav>
   </div>
  </div>
  <div id="shadow-block">
   <div id="container">
    <div id="wide-content">
     <!-- Main content -->
     <h1 class="article-title">Webscrap and iteration in R</h1>
     <article id="post-7f2c785f-b575-429c-87de-3ffb38c4c50f" data-post-id="7f2c785f-b575-429c-87de-3ffb38c4c50f">
      <div>
       <h1 class="article-header">About this post</h1>
       <p>This post is part of the series <a href="https://blog.teoten.com/series/maps-app/" title="maps-app">maps-app</a>.</p>
       <p>We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to <strong>map any region of the world with R</strong>. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with <a href="https://cran.r-project.org/web/packages/ggplot2/index.html">ggplot2</a> and <a href="https://cran.r-project.org/web/packages/maps/index.html">maps</a> packages, using support of <a href="https://www.openstreetmap.org/">Open Street Map</a> to obtain the coordinates of cities and finally making it interactive with <a href="https://shiny.rstudio.com/">shiny</a>.</p>
       <p>This series of posts share my path towards the creation of the Shiny app. It is a live project and I decided to share my path and experiences along the creation process. The posts are not only about the Shiny app, but the package I created behind it, including topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.</p>
       <p>You can find the current state of the project under <a href="https://github.com/teotenn">my GitHub</a> repo <a href="https://github.com/teotenn/mapic">mapic</a>.</p>
       <p>This post is originally written in Spanish, from the Amsterdam airport, on the way to Mexico. I hope you enjoy. Feel free to leave any type of comment and/or question at the end.</p>
       <p></p>
       <div class="article-image-container">
        <a href="https://blog.teoten.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png"><img alt="R Maps" src="https://blog.teoten.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png"></a>
       </div>
       <p></p>
       <h1 class="article-header">Motivation</h1>
       <p>As I mentioned in the previous posts in the series, I've been working lately on the code for creating the maps and I've made changes that increase the efficiency of the functions, the readability of the code, and make it easier to use. At the same it allows me to extend the functions beyond their original design.</p>
       <p>I have mentioned on a few occasions that the code evolved slowly from scripts created to generate the specific map of some country. So, the first few functions are more of a collection of the steps used to generate the map, wrapped in the form of functions to automate the process.</p>
       <p>For this reason, I wanted to make changes to adapt the functions to paradigms more suitable for functional programming, which is R's strong point. However, back then the priority was to generate the maps, and thus, most of my time was devoted to creating the maps and the debugging of the code when it was necessary. I need to add that this project is part of a voluntary work for an NGO, of which I became the director of the research division, which generated even more responsibilities and work for me. And all as a side job, separated from my main source of income (which is also based on R).</p>
       <p>However, for better or worse, 2022 was a year full of changes and challenges for me and my family, which forced me to put the project aside for a while, resign my position as responsible of the division, and focus solely on to my career, my health and my family. The result was that when I managed to regaining stability in my life, I found myself with more free time and fewer obligations to rethink the code and work on it. Additionally, my main job had a turn going from statistics to more programming oriented in R, which has given me more tools and experience to improve the code, and has motivated me to take up old lessons about functional programming and, above all, iteration.</p>
       <p>This allowed me to improve the two main functions: the one in charge of the webscrapping and the one that sends the data to SQLite. You can find the original functions in the <a href="https://blog.teoten.com/posts/2022/basic_country_map_with_r/">previous post</a> and compare it with the new, improved functions in this.</p>
       <h1 class="article-header">Webscrapp to SQLite</h1>
       <p>The <code>webscrap_to_sqlite</code> function is responsible for sending the coordinates found by Open Street Map to our database. The original function is inefficient, as it does each operation line by line. It is also very rigid in the way it directs the values of the regions, both its request to the API and the placement of the values in the database, which makes any extension or modification very complicated.</p>
       <p>For these reasons, it is the function that received the most changes, it was practically rewritten from scratch, making the search more efficient, also allowing internal search of the data already stored; more flexible, dealing with region parameters more clearly; and more understandable, improving the style of the code.</p>
       <pre><code class="highlight"><span></span><span class="n">webscrap_to_sqlite</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">db.name</span><span class="p">,</span>
                               <span class="n">dat</span><span class="p">,</span>
                               <span class="n">city</span> <span class="o">=</span> <span class="s">"City"</span><span class="p">,</span>
                               <span class="n">country</span> <span class="o">=</span> <span class="s">"Country"</span><span class="p">,</span>
                               <span class="n">region</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                               <span class="n">state</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                               <span class="n">county</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                               <span class="n">db_backup_after</span> <span class="o">=</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">## Loading libraries</span>
  <span class="nf">require</span><span class="p">(</span><span class="n">RSQLite</span><span class="p">)</span>
  <span class="nf">require</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span>

  <span class="c1">## 1. DB connection</span>
  <span class="n">con</span> <span class="o">&lt;-</span> <span class="nf">dbConnect</span><span class="p">(</span><span class="n">drv</span> <span class="o">=</span> <span class="nf">SQLite</span><span class="p">(),</span> <span class="n">dbname</span> <span class="o">=</span> <span class="n">db.name</span><span class="p">)</span>
  <span class="nf">dbExecute</span><span class="p">(</span><span class="n">conn</span> <span class="o">=</span> <span class="n">con</span><span class="p">,</span>
            <span class="s">"CREATE TABLE IF NOT EXISTS orgs</span>
<span class="s">                    (ID INTEGER UNIQUE,</span>
<span class="s">                     City TEXT,</span>
<span class="s">                     Country TEXT, </span>
<span class="s">                     Region TEXT,</span>
<span class="s">                     State TEXT,</span>
<span class="s">                     County TEXT,</span>
<span class="s">                     osm_name TEXT,</span>
<span class="s">                     lon REAL,</span>
<span class="s">                     lat REAL)"</span><span class="p">)</span>
  <span class="n">db</span> <span class="o">&lt;-</span> <span class="nf">as_tibble</span><span class="p">(</span><span class="nf">dbReadTable</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="s">"orgs"</span><span class="p">))</span>

  <span class="c1">## 2. Data filtering</span>
  <span class="n">new_coords</span> <span class="o">&lt;-</span> <span class="nf">data.frame</span><span class="p">()</span>
  <span class="n">dat_local</span> <span class="o">&lt;-</span> <span class="nf">compare_db_data</span><span class="p">(</span><span class="n">db.name</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
  <span class="n">df_len</span> <span class="o">&lt;-</span> <span class="nf">nrow</span><span class="p">(</span><span class="n">dat_local</span><span class="p">)</span>

  <span class="c1">## 3. While there are rows in DF:</span>
  <span class="nf">if </span><span class="p">(</span><span class="n">df_len</span> <span class="o">!=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">## 3.1 Define subsample size</span>
    <span class="n">dat_local</span> <span class="o">&lt;-</span> <span class="n">dat_local</span><span class="nf">[c</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">db_backup_after</span><span class="p">),</span> <span class="n">]</span>
    <span class="n">dat_local</span> <span class="o">&lt;-</span> <span class="nf">filter</span><span class="p">(</span><span class="n">dat_local</span><span class="p">,</span> <span class="nf">rowSums</span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">dat_local</span><span class="p">))</span> <span class="o">!=</span> <span class="nf">ncol</span><span class="p">(</span><span class="n">dat_local</span><span class="p">))</span>

    <span class="c1">## 3.2 for loop for the webscrapping</span>
    <span class="nf">for </span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">nrow</span><span class="p">(</span><span class="n">dat_local</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="nf">paste0</span><span class="p">(</span><span class="s">"Searching entry "</span><span class="p">,</span> <span class="n">dat_local[[</span><span class="s">"ID"</span><span class="n">]][i]</span><span class="p">))</span>
      
      <span class="c1">## 3.3 Info abstraction</span>
      <span class="n">rg</span> <span class="o">&lt;-</span> <span class="nf">ifelse</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">region</span><span class="p">),</span> <span class="s">""</span><span class="p">,</span> <span class="n">dat_local[[region]][i]</span><span class="p">)</span>
      <span class="n">st</span> <span class="o">&lt;-</span> <span class="nf">ifelse</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="s">""</span><span class="p">,</span> <span class="n">dat_local[[state]][i]</span><span class="p">)</span>
      <span class="n">ct</span> <span class="o">&lt;-</span> <span class="nf">ifelse</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">county</span><span class="p">),</span> <span class="s">""</span><span class="p">,</span> <span class="n">dat_local[[county]][i]</span><span class="p">)</span>
      <span class="n">rcity</span> <span class="o">&lt;-</span> <span class="n">dat_local[[city]][i]</span>
      <span class="n">rcountry</span> <span class="o">&lt;-</span> <span class="n">dat_local[[country]][i]</span>

      <span class="c1">## 3.4 Getting the coords</span>
      <span class="c1">## 3.4.1. First, check if they are already in the DB</span>
      <span class="n">search_query</span> <span class="o">&lt;-</span> <span class="nf">filter</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">City</span> <span class="o">==</span> <span class="n">rcity</span><span class="p">,</span> <span class="n">Country</span> <span class="o">==</span> <span class="n">rcountry</span><span class="p">,</span>
                             <span class="n">Region</span> <span class="o">==</span> <span class="n">rg</span><span class="p">,</span> <span class="n">State</span> <span class="o">==</span> <span class="n">st</span><span class="p">,</span> <span class="n">County</span> <span class="o">==</span> <span class="n">ct</span><span class="p">)</span>
      <span class="nf">if </span><span class="p">(</span><span class="nf">nrow</span><span class="p">(</span><span class="n">search_query</span> <span class="o">!=</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">coords</span> <span class="o">&lt;-</span> <span class="n">search_query[1</span><span class="p">,</span> <span class="n">]</span>
        <span class="n">coords</span><span class="o">$</span><span class="n">ID</span> <span class="o">&lt;-</span> <span class="n">dat_local[[</span><span class="s">"ID"</span><span class="n">]][i]</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Found from memory"</span><span class="p">)</span>
        
        <span class="c1">## 3.4.2 If they are not, search with OSM API</span>
      <span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
        <span class="n">coords</span> <span class="o">&lt;-</span> <span class="nf">coords_from_city</span><span class="p">(</span><span class="n">rcity</span><span class="p">,</span> <span class="n">rcountry</span><span class="p">,</span>
                                   <span class="n">Region</span> <span class="o">=</span> <span class="n">rg</span><span class="p">,</span> <span class="n">State</span> <span class="o">=</span> <span class="n">st</span><span class="p">,</span> <span class="n">County</span> <span class="o">=</span> <span class="n">ct</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">&lt;-</span> <span class="nf">cbind</span><span class="p">(</span><span class="n">ID</span> <span class="o">=</span> <span class="n">dat_local[[</span><span class="s">"ID"</span><span class="n">]][i]</span><span class="p">,</span>
                        <span class="n">City</span> <span class="o">=</span> <span class="n">rcity</span><span class="p">,</span>
                        <span class="n">Country</span> <span class="o">=</span> <span class="n">rcountry</span><span class="p">,</span>
                        <span class="n">Region</span> <span class="o">=</span> <span class="n">rg</span><span class="p">,</span>
                        <span class="n">State</span> <span class="o">=</span> <span class="n">st</span><span class="p">,</span>
                        <span class="n">County</span> <span class="o">=</span> <span class="n">ct</span><span class="p">,</span>
                        <span class="n">coords</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">new_coords</span> <span class="o">&lt;-</span> <span class="nf">rbind</span><span class="p">(</span><span class="n">new_coords</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">## Send only new results to DB</span>
    <span class="nf">dbWriteTable</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="s">"orgs"</span><span class="p">,</span> <span class="n">new_coords</span><span class="p">,</span> <span class="n">append</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
    <span class="nf">dbDisconnect</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>

    <span class="c1">## 3.4.3 Repeat</span>
    <span class="nf">webscrap_to_sqlite</span><span class="p">(</span><span class="n">db.name</span> <span class="o">=</span> <span class="n">db.name</span><span class="p">,</span>
                       <span class="n">dat</span> <span class="o">=</span> <span class="n">dat</span><span class="p">,</span>
                       <span class="n">city</span> <span class="o">=</span> <span class="n">city</span><span class="p">,</span>
                       <span class="n">country</span> <span class="o">=</span> <span class="n">country</span><span class="p">,</span>
                       <span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="p">,</span>
                       <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">,</span>
                       <span class="n">county</span> <span class="o">=</span> <span class="n">county</span><span class="p">,</span>
                       <span class="n">db_backup_after</span> <span class="o">=</span> <span class="n">db_backup_after</span><span class="p">)</span>

    <span class="c1">## 4. Exit iteration</span>
  <span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
    <span class="n">db_final</span> <span class="o">&lt;-</span> <span class="nf">import_db_as_df</span><span class="p">(</span><span class="n">db.name</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">&lt;-</span> <span class="nf">nrow</span><span class="p">(</span><span class="n">db_final</span><span class="p">)</span>
    <span class="n">not_found</span> <span class="o">&lt;-</span> <span class="nf">nrow</span><span class="p">(</span><span class="n">db_final</span><span class="nf">[is.na</span><span class="p">(</span><span class="n">db_final</span><span class="o">$</span><span class="n">lat</span><span class="p">),</span> <span class="n">]</span><span class="p">)</span>
    <span class="nf">message</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="s">"Search finished.\n"</span><span class="p">,</span>
                  <span class="n">size</span><span class="p">,</span> <span class="s">"entries searched.\n"</span><span class="p">,</span>
                  <span class="n">not_found</span><span class="p">,</span> <span class="s">"ENTRIES NOT FOUND"</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>        
</code></pre>
       <p>The function starts by calling the necessary libraries and (1) connecting to the database, creating it if necessary. (2) Then it generates two data frames, an empty one that will store new coordinates and a relative one that contains only the data that does not yet exist in the database. (3) So, as long as there is data in this last data frame, the function will continue to loop.</p>
       <p>(3.1) We then define the subsample, which is a subset of <code>dat_local</code> the size of <code>db_backup_after</code> and focus solely on this subsample. (3.2) On this subsample we make the iterations using <code>for</code> to obtain the coordinates. First (3.3) we prepare the data as strings and then (3.4) we look up the coordinates. (3.4.1) If they already exist in the database we take it from there, and if not (3.4.2) they are searched using <code>coords_from_city</code>. Finally, (3.4.3) we iterate all over again, allowing the function to call itself.</p>
       <p>Since step 2 filters the data that is not yet in the database and step 3 places the results of new searches in an empty data frame, the function calls itself and applies only for each subset of data. When <code>compare_db_data</code> finally returns 0 values because all the data that was fed into the function is already contained in the database, we can exit the function. In this case I decided to import the data again from SQLite to get details of the search, and end the iteration by sending a message to the user about the total number of entries and the number of which were not found.</p>
       <p>If we compare this function with the one proposed in my previous post, the function is completely different but the end result is the same. The arguments used by the function are also the same and take the same values, which avoids conflicts for the user. The only new parameter is <code>db_backup_after</code> which allows us to control how many rows the iteration is done. A smaller value means more iterations, which results in higher local memory usage, but also faster in finding data that already exists in the DB. On the other hand, a higher value reduces the number of iterations but increases the number of API connections. For this reason I have given it a default value of 10. This, in addition to being a balanced value, also reduces confusion for the user who might not be familiar with the changes.</p>
       <h1 class="article-header">Remove missing values from the database</h1>
       <p>In the previous proposal, only found coordinates were sent to the database, and those not found were ignored. In the present proposal, all entries are sent to the DB. Therefore, it is important to have some option to remove the missing entries.</p>
       <p>For this I generated the function <code>remove_na_from_db</code>, a very simple function which gives the user the possibility of removing <code>NA</code>s automatically.</p>
       <pre><code class="highlight"><span></span><span class="n">remove_na_from_db</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">db.file</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">require</span><span class="p">(</span><span class="n">RSQLite</span><span class="p">)</span>
  <span class="n">con</span> <span class="o">&lt;-</span> <span class="nf">dbConnect</span><span class="p">(</span><span class="n">drv</span> <span class="o">=</span> <span class="n">RSQLite</span><span class="o">::</span><span class="nf">SQLite</span><span class="p">(),</span> <span class="n">dbname</span> <span class="o">=</span> <span class="n">db.file</span><span class="p">)</span>
  <span class="nf">dbExecute</span><span class="p">(</span><span class="n">conn</span> <span class="o">=</span> <span class="n">con</span><span class="p">,</span>
            <span class="s">"DELETE FROM orgs WHERE lon IS NULL OR trim(lon) = '';"</span><span class="p">)</span>
  <span class="nf">dbDisconnect</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
       <p>The function is just a connection to the database that issues the command to remove rows where the <code>lon</code> field is empty, in SQLite syntax. This is the safest, most direct and fastest way to do it. We could also import the data back into R, filter it, and send it back to SQLite, but this would require more local memory usage, more code, and more risk as it would require rewriting the database to SQLite entirely. . The power of the <code>RSQLite</code> library (or any other library that connects R to SQL) lies precisely in the ability to pass commands written and executed directly in SQL.</p>
       <h1 class="article-header">Obtaining the coordinates</h1>
       <p>The <code>coords_from_city</code> function also received significant changes in code readability and flexibility, and a bit less in functionality and efficiency.</p>
       <pre><code class="highlight"><span></span><span class="n">coords_from_city</span> <span class="o">&lt;-</span> <span class="nf">function</span><span class="p">(</span><span class="n">city</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                             <span class="n">country_code</span><span class="p">,</span>
                             <span class="n">region</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                             <span class="n">state</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">,</span>
                             <span class="n">county</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">require</span><span class="p">(</span><span class="s">"RJSONIO"</span><span class="p">)</span>

  <span class="c1">## 1. Abstract regions for OSM</span>
  <span class="n">CityCoded</span> <span class="o">&lt;-</span> <span class="nf">gsub</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">"%20"</span><span class="p">,</span> <span class="n">City</span><span class="p">)</span> 
  <span class="n">CountryCoded</span> <span class="o">&lt;-</span> <span class="nf">paste</span><span class="p">(</span><span class="s">"&amp;countrycodes="</span><span class="p">,</span> <span class="n">CountryTwoLetter</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span>
  <span class="n">extras</span> <span class="o">&lt;-</span> <span class="nf">c</span><span class="p">(</span><span class="n">city</span> <span class="o">=</span> <span class="n">City</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">,</span> <span class="n">region</span> <span class="o">=</span> <span class="n">Region</span><span class="p">,</span> <span class="n">county</span> <span class="o">=</span> <span class="n">County</span><span class="p">)</span>
  <span class="n">extrasCoded</span> <span class="o">&lt;-</span> <span class="s">""</span>
  <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nf">is.null</span><span class="p">(</span><span class="n">extras</span><span class="p">))</span> <span class="p">{</span>
    <span class="nf">for </span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">extras</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">if </span><span class="p">(</span><span class="n">extras[i]</span> <span class="o">!=</span> <span class="s">""</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">extras[i]</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">grepl</span><span class="p">(</span><span class="s">"^\\s*$"</span><span class="p">,</span> <span class="n">extras[i]</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">valCoded</span> <span class="o">&lt;-</span> <span class="nf">gsub</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">"%20"</span><span class="p">,</span> <span class="n">extras[i]</span><span class="p">)</span>
        <span class="n">extrasCoded</span> <span class="o">&lt;-</span> <span class="nf">paste0</span><span class="p">(</span><span class="n">extrasCoded</span><span class="p">,</span> <span class="s">"&amp;"</span><span class="p">,</span> <span class="nf">names</span><span class="p">(</span><span class="n">extras</span><span class="p">)</span><span class="n">[i]</span><span class="p">,</span> <span class="s">"="</span><span class="p">,</span> <span class="n">valCoded</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">## 2. Response</span>
  <span class="n">link</span> <span class="o">&lt;-</span> <span class="nf">paste</span><span class="p">(</span>
    <span class="s">"http://nominatim.openstreetmap.org/search?city="</span>
  <span class="p">,</span> <span class="n">extrasCoded</span>
  <span class="p">,</span> <span class="n">CountryCoded</span>
  <span class="p">,</span> <span class="s">"&amp;format=json"</span>
  <span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">""</span>
  <span class="p">)</span>

  <span class="n">response</span> <span class="o">&lt;-</span> <span class="nf">try</span><span class="p">({</span><span class="nf">fromJSON</span><span class="p">(</span><span class="n">link</span><span class="p">)},</span>
                  <span class="n">silent</span> <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>

  <span class="nf">if </span><span class="p">(</span><span class="nf">class</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="o">==</span> <span class="s">"try-error"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">stop</span><span class="p">(</span><span class="n">response[1]</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">else</span> <span class="nf">if </span><span class="p">(</span><span class="nf">class</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="o">==</span> <span class="s">"response"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">response_status</span> <span class="o">&lt;-</span> <span class="nf">http_status</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">response_status</span><span class="o">$</span><span class="n">category</span> <span class="o">!=</span> <span class="s">"Success"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">stop</span><span class="p">(</span><span class="n">response_status</span><span class="o">$</span><span class="n">message</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="n">else</span> <span class="nf">if </span><span class="p">(</span><span class="nf">is.list</span><span class="p">(</span><span class="n">response</span><span class="p">))</span> <span class="p">{</span>

    <span class="c1">## 3. Organize results</span>
    <span class="nf">if </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">message</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="s">"No results found for"</span><span class="p">,</span> <span class="n">extrasCoded</span><span class="p">))</span>
      <span class="n">coords</span> <span class="o">&lt;-</span> <span class="nf">data.frame</span><span class="p">(</span><span class="s">"lon"</span> <span class="o">=</span> <span class="kc">NA</span><span class="p">,</span> <span class="s">"lat"</span> <span class="o">=</span> <span class="kc">NA</span><span class="p">,</span> <span class="s">"osm_name"</span> <span class="o">=</span> <span class="nf">as.character</span><span class="p">(</span><span class="kc">NA</span><span class="p">))</span>
      
    <span class="p">}</span> <span class="n">else</span> <span class="nf">if </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="o">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">message</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="s">"Found"</span><span class="p">,</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">display_name</span><span class="p">))</span>
      <span class="n">coords</span> <span class="o">&lt;-</span> <span class="nf">data.frame</span><span class="p">(</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">lon</span><span class="p">,</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span>
        <span class="n">osm_name</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">display_name</span>
      <span class="p">)</span>
      
    <span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
      <span class="nf">message</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="s">"Several entries found for"</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span> <span class="n">country_code</span><span class="p">))</span>
      <span class="n">coords</span> <span class="o">&lt;-</span> <span class="nf">data.frame</span><span class="p">(</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">lon</span><span class="p">,</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span>
        <span class="n">osm_name</span> <span class="o">=</span> <span class="n">response[[1]]</span><span class="o">$</span><span class="n">display_name</span>
      <span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
    
  <span class="c1">## 4. Exit as data frame</span>
  <span class="nf">return</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
       <p>The main change is in section 1, instead of passing each of the regions as its own string and formatting them one by one, I have abstracted them all into a single vector. This reduces the amount of code, memory usage, and allows us to include the city in the list, making it an optional value as well. The reason I had prepared them separately in the previous post is simply because the feature grew slowly: at first we only needed city, but then we had to use some additional fields depending on the country we were working in. To make things easier for me, I simply added each region field as needed. Now that I have time to work on the code, this was the first function I modified.</p>
       <p>Step 2 now prints messages that help us identify the error when it comes to the connection, while also stopping the process. Whether it is a local connection error, or problems on the API side, we will get a message and the process will stop, which should avoid long waiting times when there is no connection and several locations are being searched.</p>
       <p>Step 3 changes the organization of the results a bit, always returning a data frame with the same columns when the results were not found, but now with empty fields in such case. This helps the functions presented above to populate the database. Additionally, when many results were found, this information is printed on the screen; for now this is for information purposes only. The idea is to keep this space to make changes in the future that allow us to select the option interactively. This is something I still need to think about and plan properly because on one hand I want to use it in a Shiny app, and on the other we want to keep the ability for web scrapping to happen automatically with as little intervention as possible.</p>
       <p>As I mentioned before, these new features also allow us to perform searches with the empty city value. This was a requested requirement in the last version, as some users started making maps by region, while others, not finding very small cities, decided to group the data by region. Thanks to the changes made to <code>coords_from_city</code>, the <code>webscrap_to_sqlite</code> function can now return results when the value for city is <code>NA</code>, assuming that the coordinates for the region or state are found. Here it is important to mention that it is recommended to use the <code>state</code> argument for region search, for some reason this works better in the OSM API. As an example, the search <code>coords_from_city(state = "Castilla La Mancha", country_code = "ES")</code> returns the expected results, despite of the fact that Spain has no states; however if we do <code>coords_from_city(region = "Castilla La Mancha", country_code = "ES")</code> nominatim does not find the results.</p>
       <h1 class="article-header">Conclusions</h1>
       <p>These changes have been very important in speeding up the coordinate search process and automating map creation. On the other hand, it allowed me to style the code more and improve its efficiency. Since my main project for now is turning it into a Shiny app, it was important for me to improve the code and the efficiency before dealing with the details of the server. Since this is recent work that I have been doing in the last few months, I decided to share it right away now that I have fresh information on the changes. I hope it can help more than one to make more abstract code and practice recursion.</p>
      </div>
     </article>
     <div class="article-comments">
      <script src="https://utteranc.es/client.js" repo="teotenn/blog.teoten.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
     </div>
    </div>
    <button id="toggle-button">&gt;</button>
    <div id="sidebar" class="expanded">
     <a href="https://blog.teoten.com/about/"> <img src="https://blog.teoten.com/img/tt-avatar.png" alt="Teoten" class="sidebar-image"> </a>
     <h2 class="h-sidebar">Links</h2>
     <ul>
      <li><a href="https://www.r-project.org/">The R Project</a></li>
      <li><a href="https://www.r-bloggers.com/">R-bloggers</a></li>
      <li><a href="https://clojure.org/">Clojure</a></li>
      <li><a href="https://www.gnu.org/software/emacs/">GNU Emacs</a></li>
     </ul>
     <h2 class="h-sidebar">Socials</h2>
     <ul class="horizontal-list">
      <li><a href="https://www.linkedin.com/in/teoten/"><i class="fab fa-linkedin-in"></i></a></li>
      <li><a href="https://codeberg.org/teoten"><i class="fab fa-github"></i></a></li>
      <li><a href="https://emacs.ch/@teoten"><i class="fab fa-mastodon"></i></a></li>
     </ul>
    </div>
   </div>
  </div>
  <script>
    // JavaScript function to handle theme toggling
    function toggleTheme() {
	document.body.classList.toggle('dark-theme');

	if (document.body.classList.contains('dark-theme')) {
	    localStorage.setItem('theme', 'dark');
	} else {
	    localStorage.setItem('theme', 'light');
	}
	// alert("Theme changed!")
    }

    // Check and apply the saved theme preference on page load
    window.onload = function() {
	const savedTheme = localStorage.getItem('theme');
	if (savedTheme === 'dark') {
	    document.body.classList.add('dark-theme');
	}
    };

      // Sidebar
      const toggleButton = document.getElementById('toggle-button');
      const sidebar = document.getElementById('sidebar');

      toggleButton.addEventListener('click', () => {
	  if (sidebar.classList.contains('collapsed')) {
              sidebar.classList.remove('collapsed');
              sidebar.classList.add('expanded');
	  } else {
              sidebar.classList.remove('expanded');
              sidebar.classList.add('collapsed');
	  }
      });

    </script>
 </body>
</html>